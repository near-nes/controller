"""NRP Neural Engine for the complete control simulation."""

import datetime

import structlog
from config.MasterParams import MasterParams
from neural.nest_adapter import initialize_nest, nest
from neural_simulation_lib import (
    create_controllers,
    setup_environment,
    setup_nest_kernel,
)
from nrp_core.engines.python_json import EngineScript
from utils_common.generate_analog_signals import generate_signals

NANO_SEC = 1e-9


class Script(EngineScript):
    def __init__(self):
        super().__init__()
        self.log = structlog.get_logger("nrp_neural_engine")
        initialize_nest("NRP")
        self.master_config = None
        self.controllers = []
        self.run_paths = None  # TOCHECK: How run_paths are handled in NRP context

    def initialize(self):
        self.log.info("NRP Neural Engine: Initializing...")

        # TOCHECK: How to get master_config and run_paths in NRP context
        # For now, a simplified loading or placeholder
        # In a real NRP setup, these would likely come from the experiment configuration
        # or be generated by a pre-simulation script.

        # Placeholder for run_paths and master_config for initial setup
        # This needs to be properly integrated with NRP's configuration system
        run_timestamp_str = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
        # Assuming RunPaths can be initialized without MPI context for now
        # TOCHECK: This needs to be aligned with NRP's data handling and path management
        from config.paths import (
            RunPaths,  # Re-import locally to avoid circular dependency if needed
        )

        self.run_paths = RunPaths.from_run_id(run_timestamp_str)

        # Setup logging for the engine process
        # TOCHECK: NRP might handle logging, but this is for internal engine logs
        # setup_logging(
        #     None,  # TOCHECK: MPI.COMM_WORLD is not available in NRP engine
        #     log_dir_path=self.run_paths.logs,
        #     timestamp_str=run_timestamp_str,
        #     log_level=os.environ.get("LOG_LEVEL", "DEBUG"),
        # )
        self.log: structlog.stdlib.BoundLogger = structlog.get_logger("nrp_neural")
        self.log.info(f"Engine Log Path: {self.run_paths.logs}")

        # Load MasterParams
        # TOCHECK: This needs to be loaded from NRP's experiment configuration
        # For now, we'll create a dummy one or load from a known path if available
        # Assuming a master_config.json exists or can be generated
        # For demonstration, let's assume it's loaded from a fixed path or generated
        # This part needs to be properly configured in a real NRP experiment
        # For now, we'll use a simplified approach or assume a default config
        # If MasterParams.from_runpaths expects files to exist, this might fail
        self.master_config = MasterParams.from_runpaths(run_paths=self.run_paths)
        self.log.info("MasterParams loaded successfully.")

        # Setup environment and NEST kernel using the library functions
        setup_environment()
        setup_nest_kernel(
            self.master_config.simulation,
            self.master_config.simulation.seed,
            self.run_paths.data_nest,
        )
        self.log.info("Environment and NEST kernel setup complete.")

        # Generate signals
        trj, motor_commands = generate_signals(
            self.master_config.experiment, self.master_config.simulation
        )
        self.log.info("Input data (trajectory, motor_commands) generated.")

        # Create controllers
        self.controllers = create_controllers(
            self.master_config,
            trj,
            motor_commands,
        )
        self.log.info(f"Created {len(self.controllers)} controllers.")

        # Register datapacks
        # TOCHECK: Define actual datapack names and structures based on communication needs
        self._registerDataPack(
            "motor_commands_out"
        )  # Output for motor commands to plant
        self._registerDataPack("feedback_in")  # Input for sensory feedback from plant
        self._setDataPack(
            "motor_commands_out", {"data": [0.0] * self.master_config.NJT}
        )  # Initial dummy data
        self.log.info("Datapacks registered: motor_commands_out, feedback_in")

        nest.Prepare()  # Added Prepare as per feedback
        self.log.info("NRP Neural Engine: Initialization complete.")

    def runLoop(self, timestep_ns):
        self.log.debug(f"NRP Neural Engine: runLoop at timestep {timestep_ns} ns")

        # Read sensory data from input datapack
        # The structure of feedback_in will depend on the plant engine
        feedback_data = self._getDataPack("feedback_in")
        # self.log.debug(f"Received feedback: {feedback_data}")

        # Update the simulation based on the input
        # This is a placeholder. The actual logic to feed feedback into the
        # neural network and update controller states would go here.
        # For example, if feedback_data contains joint angles, you might
        # update the input layer of your neural network or adjust internal
        # controller states based on this information.
        # Example: self.controllers[0].update_sensory_input(feedback_data["joint_angles"])

        # Advance the NEST simulation by one step
        nest.Run(timestep_ns * NANO_SEC)  # Changed from Simulate to Run as per feedback
        # self.log.debug(f"NEST simulated for {timestep_ns * NANO_SEC} seconds.")
        # TOCHECK: In runLoop, you cannot run nest_client.SetStatus()

        # Retrieve simulation results (e.g., motor commands) from the controllers
        # This will depend on how the Controller class exposes its outputs.
        # Assuming each controller provides a single motor command.
        motor_commands_to_send = [
            controller.get_motor_command() for controller in self.controllers
        ]
        # self.log.debug(f"Retrieved motor commands: {motor_commands_to_send}")

        # Write the resulting motor commands to an output datapack
        self._setDataPack("motor_commands_out", {"data": motor_commands_to_send})
        # self.log.debug(f"Sent motor commands: {motor_commands_to_send}")

    def shutdown(self):
        self.log.info("NRP Neural Engine: Shutting down.")
        # Data collapsing and plotting logic from the original main_simulation.py
        # can be adapted here or handled by a separate NRP post-processing step.
        # For now, we'll just log that it would occur.
        self.log.info("Data collapsing and plotting (if enabled) would occur here.")
        # Example of how to call collapse_files if needed:
        # from neural.data_handling import collapse_files
        # pop_views = []
        # for controller in self.controllers:
        #     pop_views.extend(controller.get_all_recorded_views())
        # collapse_files(self.run_paths.data_nest, pop_views) # TOCHECK: comm is not available
        nest.Cleanup()

    # def reset(self):
    #     self.log.info("NRP Neural Engine: Resetting.")
    #     self.nest_client.Cleanup()

    #     if self.nest_client:
    #         self.nest_client.ResetKernel()

    #     self.initialize()
